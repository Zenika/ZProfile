schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# columns and relationships of "Agency"
type Agency implements Node {
  # An array relationship
  UserAgencies(
    # distinct select on columns
    distinct_on: [UserAgency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserAgency_order_by!]

    # filter the rows returned
    where: UserAgency_bool_exp
  ): [UserAgency!]!

  # An aggregated array relationship
  UserAgencies_aggregate(
    # distinct select on columns
    distinct_on: [UserAgency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserAgency_order_by!]

    # filter the rows returned
    where: UserAgency_bool_exp
  ): UserAgency_aggregate!

  # An array relationship connection
  UserAgencies_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserAgency_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserAgency_order_by!]

    # filter the rows returned
    where: UserAgency_bool_exp
  ): UserAgencyConnection!
  id: ID!
  name: String!
}

# aggregated selection of "Agency"
type Agency_aggregate {
  aggregate: Agency_aggregate_fields
  nodes: [Agency!]!
}

# aggregate fields of "Agency"
type Agency_aggregate_fields {
  count(columns: [Agency_select_column!], distinct: Boolean): Int
  max: Agency_max_fields
  min: Agency_min_fields
}

# order by aggregate values of table "Agency"
input Agency_aggregate_order_by {
  count: order_by
  max: Agency_max_order_by
  min: Agency_min_order_by
}

# input type for inserting array relation for remote table "Agency"
input Agency_arr_rel_insert_input {
  data: [Agency_insert_input!]!
  on_conflict: Agency_on_conflict
}

# Boolean expression to filter rows from the table "Agency". All fields are combined with a logical 'AND'.
input Agency_bool_exp {
  UserAgencies: UserAgency_bool_exp
  _and: [Agency_bool_exp]
  _not: Agency_bool_exp
  _or: [Agency_bool_exp]
  name: String_comparison_exp
}

# unique or primary key constraints on table "Agency"
enum Agency_constraint {
  # unique or primary key constraint
  Agency_pkey
}

# input type for inserting data into table "Agency"
input Agency_insert_input {
  UserAgencies: UserAgency_arr_rel_insert_input
  name: String
}

# aggregate max on columns
type Agency_max_fields {
  name: String
}

# order by max() on columns of table "Agency"
input Agency_max_order_by {
  name: order_by
}

# aggregate min on columns
type Agency_min_fields {
  name: String
}

# order by min() on columns of table "Agency"
input Agency_min_order_by {
  name: order_by
}

# response of any mutation on the table "Agency"
type Agency_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [Agency!]!
}

# input type for inserting object relation for remote table "Agency"
input Agency_obj_rel_insert_input {
  data: Agency_insert_input!
  on_conflict: Agency_on_conflict
}

# on conflict condition type for table "Agency"
input Agency_on_conflict {
  constraint: Agency_constraint!
  update_columns: [Agency_update_column!]!
  where: Agency_bool_exp
}

# ordering options when selecting data from "Agency"
input Agency_order_by {
  UserAgencies_aggregate: UserAgency_aggregate_order_by
  name: order_by
}

# primary key columns input for table: "Agency"
input Agency_pk_columns_input {
  name: String!
}

# select columns of table "Agency"
enum Agency_select_column {
  # column name
  name
}

# input type for updating data in table "Agency"
input Agency_set_input {
  name: String
}

# update columns of table "Agency"
enum Agency_update_column {
  # column name
  name
}

# A Relay Connection object on "Agency"
type AgencyConnection {
  edges: [AgencyEdge!]!
  pageInfo: PageInfo!
}

type AgencyEdge {
  cursor: String!
  node: Agency!
}

scalar date

# expression to compare columns of type date. All fields are combined with logical 'AND'.
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# mutation root
type mutation_root {
  # delete data from the table: "Agency"
  delete_Agency(
    # filter the rows which have to be deleted
    where: Agency_bool_exp!
  ): Agency_mutation_response

  # delete single row from the table: "Agency"
  delete_Agency_by_pk(name: String!): Agency

  # delete data from the table: "Skill"
  delete_Skill(
    # filter the rows which have to be deleted
    where: Skill_bool_exp!
  ): Skill_mutation_response

  # delete single row from the table: "Skill"
  delete_Skill_by_pk(id: uuid!): Skill

  # delete data from the table: "TechnicalAppetite"
  delete_TechnicalAppetite(
    # filter the rows which have to be deleted
    where: TechnicalAppetite_bool_exp!
  ): TechnicalAppetite_mutation_response

  # delete single row from the table: "TechnicalAppetite"
  delete_TechnicalAppetite_by_pk(created_at: date!, skillId: uuid!, userEmail: String!): TechnicalAppetite

  # delete data from the table: "Topic"
  delete_Topic(
    # filter the rows which have to be deleted
    where: Topic_bool_exp!
  ): Topic_mutation_response

  # delete single row from the table: "Topic"
  delete_Topic_by_pk(id: uuid!): Topic

  # delete data from the table: "User"
  delete_User(
    # filter the rows which have to be deleted
    where: User_bool_exp!
  ): User_mutation_response

  # delete data from the table: "UserAgency"
  delete_UserAgency(
    # filter the rows which have to be deleted
    where: UserAgency_bool_exp!
  ): UserAgency_mutation_response

  # delete single row from the table: "UserAgency"
  delete_UserAgency_by_pk(id: uuid!): UserAgency

  # delete data from the table: "UserSkill"
  delete_UserSkill(
    # filter the rows which have to be deleted
    where: UserSkill_bool_exp!
  ): UserSkill_mutation_response

  # delete single row from the table: "UserSkill"
  delete_UserSkill_by_pk(created_at: date!, skillId: uuid!, userEmail: String!): UserSkill

  # delete data from the table: "UserTopic"
  delete_UserTopic(
    # filter the rows which have to be deleted
    where: UserTopic_bool_exp!
  ): UserTopic_mutation_response

  # delete single row from the table: "UserTopic"
  delete_UserTopic_by_pk(created_at: date!, topicId: uuid!, userEmail: String!): UserTopic

  # delete single row from the table: "User"
  delete_User_by_pk(email: String!): User

  # insert data into the table: "Agency"
  insert_Agency(
    # the rows to be inserted
    objects: [Agency_insert_input!]!

    # on conflict condition
    on_conflict: Agency_on_conflict
  ): Agency_mutation_response

  # insert a single row into the table: "Agency"
  insert_Agency_one(
    # the row to be inserted
    object: Agency_insert_input!

    # on conflict condition
    on_conflict: Agency_on_conflict
  ): Agency

  # insert data into the table: "Skill"
  insert_Skill(
    # the rows to be inserted
    objects: [Skill_insert_input!]!

    # on conflict condition
    on_conflict: Skill_on_conflict
  ): Skill_mutation_response

  # insert a single row into the table: "Skill"
  insert_Skill_one(
    # the row to be inserted
    object: Skill_insert_input!

    # on conflict condition
    on_conflict: Skill_on_conflict
  ): Skill

  # insert data into the table: "TechnicalAppetite"
  insert_TechnicalAppetite(
    # the rows to be inserted
    objects: [TechnicalAppetite_insert_input!]!

    # on conflict condition
    on_conflict: TechnicalAppetite_on_conflict
  ): TechnicalAppetite_mutation_response

  # insert a single row into the table: "TechnicalAppetite"
  insert_TechnicalAppetite_one(
    # the row to be inserted
    object: TechnicalAppetite_insert_input!

    # on conflict condition
    on_conflict: TechnicalAppetite_on_conflict
  ): TechnicalAppetite

  # insert data into the table: "Topic"
  insert_Topic(
    # the rows to be inserted
    objects: [Topic_insert_input!]!

    # on conflict condition
    on_conflict: Topic_on_conflict
  ): Topic_mutation_response

  # insert a single row into the table: "Topic"
  insert_Topic_one(
    # the row to be inserted
    object: Topic_insert_input!

    # on conflict condition
    on_conflict: Topic_on_conflict
  ): Topic

  # insert data into the table: "User"
  insert_User(
    # the rows to be inserted
    objects: [User_insert_input!]!

    # on conflict condition
    on_conflict: User_on_conflict
  ): User_mutation_response

  # insert data into the table: "UserAgency"
  insert_UserAgency(
    # the rows to be inserted
    objects: [UserAgency_insert_input!]!

    # on conflict condition
    on_conflict: UserAgency_on_conflict
  ): UserAgency_mutation_response

  # insert a single row into the table: "UserAgency"
  insert_UserAgency_one(
    # the row to be inserted
    object: UserAgency_insert_input!

    # on conflict condition
    on_conflict: UserAgency_on_conflict
  ): UserAgency

  # insert data into the table: "UserSkill"
  insert_UserSkill(
    # the rows to be inserted
    objects: [UserSkill_insert_input!]!

    # on conflict condition
    on_conflict: UserSkill_on_conflict
  ): UserSkill_mutation_response

  # insert a single row into the table: "UserSkill"
  insert_UserSkill_one(
    # the row to be inserted
    object: UserSkill_insert_input!

    # on conflict condition
    on_conflict: UserSkill_on_conflict
  ): UserSkill

  # insert data into the table: "UserTopic"
  insert_UserTopic(
    # the rows to be inserted
    objects: [UserTopic_insert_input!]!

    # on conflict condition
    on_conflict: UserTopic_on_conflict
  ): UserTopic_mutation_response

  # insert a single row into the table: "UserTopic"
  insert_UserTopic_one(
    # the row to be inserted
    object: UserTopic_insert_input!

    # on conflict condition
    on_conflict: UserTopic_on_conflict
  ): UserTopic

  # insert a single row into the table: "User"
  insert_User_one(
    # the row to be inserted
    object: User_insert_input!

    # on conflict condition
    on_conflict: User_on_conflict
  ): User

  # update data of the table: "Agency"
  update_Agency(
    # sets the columns of the filtered rows to the given values
    _set: Agency_set_input

    # filter the rows which have to be updated
    where: Agency_bool_exp!
  ): Agency_mutation_response

  # update single row of the table: "Agency"
  update_Agency_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: Agency_set_input
    pk_columns: Agency_pk_columns_input!
  ): Agency

  # update data of the table: "Skill"
  update_Skill(
    # sets the columns of the filtered rows to the given values
    _set: Skill_set_input

    # filter the rows which have to be updated
    where: Skill_bool_exp!
  ): Skill_mutation_response

  # update single row of the table: "Skill"
  update_Skill_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: Skill_set_input
    pk_columns: Skill_pk_columns_input!
  ): Skill

  # update data of the table: "TechnicalAppetite"
  update_TechnicalAppetite(
    # increments the integer columns with given value of the filtered values
    _inc: TechnicalAppetite_inc_input

    # sets the columns of the filtered rows to the given values
    _set: TechnicalAppetite_set_input

    # filter the rows which have to be updated
    where: TechnicalAppetite_bool_exp!
  ): TechnicalAppetite_mutation_response

  # update single row of the table: "TechnicalAppetite"
  update_TechnicalAppetite_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: TechnicalAppetite_inc_input

    # sets the columns of the filtered rows to the given values
    _set: TechnicalAppetite_set_input
    pk_columns: TechnicalAppetite_pk_columns_input!
  ): TechnicalAppetite

  # update data of the table: "Topic"
  update_Topic(
    # sets the columns of the filtered rows to the given values
    _set: Topic_set_input

    # filter the rows which have to be updated
    where: Topic_bool_exp!
  ): Topic_mutation_response

  # update single row of the table: "Topic"
  update_Topic_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: Topic_set_input
    pk_columns: Topic_pk_columns_input!
  ): Topic

  # update data of the table: "User"
  update_User(
    # sets the columns of the filtered rows to the given values
    _set: User_set_input

    # filter the rows which have to be updated
    where: User_bool_exp!
  ): User_mutation_response

  # update data of the table: "UserAgency"
  update_UserAgency(
    # sets the columns of the filtered rows to the given values
    _set: UserAgency_set_input

    # filter the rows which have to be updated
    where: UserAgency_bool_exp!
  ): UserAgency_mutation_response

  # update single row of the table: "UserAgency"
  update_UserAgency_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: UserAgency_set_input
    pk_columns: UserAgency_pk_columns_input!
  ): UserAgency

  # update data of the table: "UserSkill"
  update_UserSkill(
    # increments the integer columns with given value of the filtered values
    _inc: UserSkill_inc_input

    # sets the columns of the filtered rows to the given values
    _set: UserSkill_set_input

    # filter the rows which have to be updated
    where: UserSkill_bool_exp!
  ): UserSkill_mutation_response

  # update single row of the table: "UserSkill"
  update_UserSkill_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: UserSkill_inc_input

    # sets the columns of the filtered rows to the given values
    _set: UserSkill_set_input
    pk_columns: UserSkill_pk_columns_input!
  ): UserSkill

  # update data of the table: "UserTopic"
  update_UserTopic(
    # sets the columns of the filtered rows to the given values
    _set: UserTopic_set_input

    # filter the rows which have to be updated
    where: UserTopic_bool_exp!
  ): UserTopic_mutation_response

  # update single row of the table: "UserTopic"
  update_UserTopic_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: UserTopic_set_input
    pk_columns: UserTopic_pk_columns_input!
  ): UserTopic

  # update single row of the table: "User"
  update_User_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: User_set_input
    pk_columns: User_pk_columns_input!
  ): User
}

# An object with globally unique ID
interface Node {
  # A globally unique identifier
  id: ID!
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

# query root
type query_root {
  # fetch data from the table: "Agency"
  Agency_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [Agency_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [Agency_order_by!]

    # filter the rows returned
    where: Agency_bool_exp
  ): AgencyConnection!

  # fetch data from the table: "Skill"
  Skill_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [Skill_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [Skill_order_by!]

    # filter the rows returned
    where: Skill_bool_exp
  ): SkillConnection!

  # fetch data from the table: "TechnicalAppetite"
  TechnicalAppetite_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [TechnicalAppetite_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [TechnicalAppetite_order_by!]

    # filter the rows returned
    where: TechnicalAppetite_bool_exp
  ): TechnicalAppetiteConnection!

  # fetch data from the table: "Topic"
  Topic_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [Topic_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [Topic_order_by!]

    # filter the rows returned
    where: Topic_bool_exp
  ): TopicConnection!

  # fetch data from the table: "UserAgency"
  UserAgency_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserAgency_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserAgency_order_by!]

    # filter the rows returned
    where: UserAgency_bool_exp
  ): UserAgencyConnection!

  # fetch data from the table: "UserSkill"
  UserSkill_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserSkill_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserSkill_order_by!]

    # filter the rows returned
    where: UserSkill_bool_exp
  ): UserSkillConnection!

  # fetch data from the table: "UserTopic"
  UserTopic_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserTopic_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserTopic_order_by!]

    # filter the rows returned
    where: UserTopic_bool_exp
  ): UserTopicConnection!

  # fetch data from the table: "User"
  User_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [User_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [User_order_by!]

    # filter the rows returned
    where: User_bool_exp
  ): UserConnection!
  node(
    # A globally unique id
    id: ID!
  ): Node
}

# columns and relationships of "Skill"
type Skill implements Node {
  # An array relationship
  TechnicalAppetites(
    # distinct select on columns
    distinct_on: [TechnicalAppetite_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [TechnicalAppetite_order_by!]

    # filter the rows returned
    where: TechnicalAppetite_bool_exp
  ): [TechnicalAppetite!]!

  # An aggregated array relationship
  TechnicalAppetites_aggregate(
    # distinct select on columns
    distinct_on: [TechnicalAppetite_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [TechnicalAppetite_order_by!]

    # filter the rows returned
    where: TechnicalAppetite_bool_exp
  ): TechnicalAppetite_aggregate!

  # An array relationship connection
  TechnicalAppetites_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [TechnicalAppetite_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [TechnicalAppetite_order_by!]

    # filter the rows returned
    where: TechnicalAppetite_bool_exp
  ): TechnicalAppetiteConnection!

  # An object relationship
  Topic: Topic!

  # An array relationship
  UserSkills(
    # distinct select on columns
    distinct_on: [UserSkill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserSkill_order_by!]

    # filter the rows returned
    where: UserSkill_bool_exp
  ): [UserSkill!]!

  # An aggregated array relationship
  UserSkills_aggregate(
    # distinct select on columns
    distinct_on: [UserSkill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserSkill_order_by!]

    # filter the rows returned
    where: UserSkill_bool_exp
  ): UserSkill_aggregate!

  # An array relationship connection
  UserSkills_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserSkill_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserSkill_order_by!]

    # filter the rows returned
    where: UserSkill_bool_exp
  ): UserSkillConnection!
  id: ID!
  name: String!
  topicId: uuid!
}

# aggregated selection of "Skill"
type Skill_aggregate {
  aggregate: Skill_aggregate_fields
  nodes: [Skill!]!
}

# aggregate fields of "Skill"
type Skill_aggregate_fields {
  count(columns: [Skill_select_column!], distinct: Boolean): Int
  max: Skill_max_fields
  min: Skill_min_fields
}

# order by aggregate values of table "Skill"
input Skill_aggregate_order_by {
  count: order_by
  max: Skill_max_order_by
  min: Skill_min_order_by
}

# input type for inserting array relation for remote table "Skill"
input Skill_arr_rel_insert_input {
  data: [Skill_insert_input!]!
  on_conflict: Skill_on_conflict
}

# Boolean expression to filter rows from the table "Skill". All fields are combined with a logical 'AND'.
input Skill_bool_exp {
  TechnicalAppetites: TechnicalAppetite_bool_exp
  Topic: Topic_bool_exp
  UserSkills: UserSkill_bool_exp
  _and: [Skill_bool_exp]
  _not: Skill_bool_exp
  _or: [Skill_bool_exp]
  id: uuid_comparison_exp
  name: String_comparison_exp
  topicId: uuid_comparison_exp
}

# unique or primary key constraints on table "Skill"
enum Skill_constraint {
  # unique or primary key constraint
  Skill_name_key

  # unique or primary key constraint
  Skill_pkey
}

# input type for inserting data into table "Skill"
input Skill_insert_input {
  TechnicalAppetites: TechnicalAppetite_arr_rel_insert_input
  Topic: Topic_obj_rel_insert_input
  UserSkills: UserSkill_arr_rel_insert_input
  id: uuid
  name: String
  topicId: uuid
}

# aggregate max on columns
type Skill_max_fields {
  id: uuid
  name: String
  topicId: uuid
}

# order by max() on columns of table "Skill"
input Skill_max_order_by {
  id: order_by
  name: order_by
  topicId: order_by
}

# aggregate min on columns
type Skill_min_fields {
  id: uuid
  name: String
  topicId: uuid
}

# order by min() on columns of table "Skill"
input Skill_min_order_by {
  id: order_by
  name: order_by
  topicId: order_by
}

# response of any mutation on the table "Skill"
type Skill_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [Skill!]!
}

# input type for inserting object relation for remote table "Skill"
input Skill_obj_rel_insert_input {
  data: Skill_insert_input!
  on_conflict: Skill_on_conflict
}

# on conflict condition type for table "Skill"
input Skill_on_conflict {
  constraint: Skill_constraint!
  update_columns: [Skill_update_column!]!
  where: Skill_bool_exp
}

# ordering options when selecting data from "Skill"
input Skill_order_by {
  TechnicalAppetites_aggregate: TechnicalAppetite_aggregate_order_by
  Topic: Topic_order_by
  UserSkills_aggregate: UserSkill_aggregate_order_by
  id: order_by
  name: order_by
  topicId: order_by
}

# primary key columns input for table: "Skill"
input Skill_pk_columns_input {
  id: uuid!
}

# select columns of table "Skill"
enum Skill_select_column {
  # column name
  id

  # column name
  name

  # column name
  topicId
}

# input type for updating data in table "Skill"
input Skill_set_input {
  id: uuid
  name: String
  topicId: uuid
}

# update columns of table "Skill"
enum Skill_update_column {
  # column name
  id

  # column name
  name

  # column name
  topicId
}

# A Relay Connection object on "Skill"
type SkillConnection {
  edges: [SkillEdge!]!
  pageInfo: PageInfo!
}

type SkillEdge {
  cursor: String!
  node: Skill!
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "Agency"
  Agency_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [Agency_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [Agency_order_by!]

    # filter the rows returned
    where: Agency_bool_exp
  ): AgencyConnection!

  # fetch data from the table: "Skill"
  Skill_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [Skill_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [Skill_order_by!]

    # filter the rows returned
    where: Skill_bool_exp
  ): SkillConnection!

  # fetch data from the table: "TechnicalAppetite"
  TechnicalAppetite_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [TechnicalAppetite_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [TechnicalAppetite_order_by!]

    # filter the rows returned
    where: TechnicalAppetite_bool_exp
  ): TechnicalAppetiteConnection!

  # fetch data from the table: "Topic"
  Topic_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [Topic_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [Topic_order_by!]

    # filter the rows returned
    where: Topic_bool_exp
  ): TopicConnection!

  # fetch data from the table: "UserAgency"
  UserAgency_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserAgency_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserAgency_order_by!]

    # filter the rows returned
    where: UserAgency_bool_exp
  ): UserAgencyConnection!

  # fetch data from the table: "UserSkill"
  UserSkill_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserSkill_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserSkill_order_by!]

    # filter the rows returned
    where: UserSkill_bool_exp
  ): UserSkillConnection!

  # fetch data from the table: "UserTopic"
  UserTopic_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserTopic_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserTopic_order_by!]

    # filter the rows returned
    where: UserTopic_bool_exp
  ): UserTopicConnection!

  # fetch data from the table: "User"
  User_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [User_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [User_order_by!]

    # filter the rows returned
    where: User_bool_exp
  ): UserConnection!
  node(
    # A globally unique id
    id: ID!
  ): Node
}

# columns and relationships of "TechnicalAppetite"
type TechnicalAppetite implements Node {
  # An object relationship
  Skill: Skill!

  # An object relationship
  User: User!
  created_at: date!
  id: ID!
  level: Int!
  skillId: uuid!
  userEmail: String!
}

# aggregated selection of "TechnicalAppetite"
type TechnicalAppetite_aggregate {
  aggregate: TechnicalAppetite_aggregate_fields
  nodes: [TechnicalAppetite!]!
}

# aggregate fields of "TechnicalAppetite"
type TechnicalAppetite_aggregate_fields {
  avg: TechnicalAppetite_avg_fields
  count(columns: [TechnicalAppetite_select_column!], distinct: Boolean): Int
  max: TechnicalAppetite_max_fields
  min: TechnicalAppetite_min_fields
  stddev: TechnicalAppetite_stddev_fields
  stddev_pop: TechnicalAppetite_stddev_pop_fields
  stddev_samp: TechnicalAppetite_stddev_samp_fields
  sum: TechnicalAppetite_sum_fields
  var_pop: TechnicalAppetite_var_pop_fields
  var_samp: TechnicalAppetite_var_samp_fields
  variance: TechnicalAppetite_variance_fields
}

# order by aggregate values of table "TechnicalAppetite"
input TechnicalAppetite_aggregate_order_by {
  avg: TechnicalAppetite_avg_order_by
  count: order_by
  max: TechnicalAppetite_max_order_by
  min: TechnicalAppetite_min_order_by
  stddev: TechnicalAppetite_stddev_order_by
  stddev_pop: TechnicalAppetite_stddev_pop_order_by
  stddev_samp: TechnicalAppetite_stddev_samp_order_by
  sum: TechnicalAppetite_sum_order_by
  var_pop: TechnicalAppetite_var_pop_order_by
  var_samp: TechnicalAppetite_var_samp_order_by
  variance: TechnicalAppetite_variance_order_by
}

# input type for inserting array relation for remote table "TechnicalAppetite"
input TechnicalAppetite_arr_rel_insert_input {
  data: [TechnicalAppetite_insert_input!]!
  on_conflict: TechnicalAppetite_on_conflict
}

# aggregate avg on columns
type TechnicalAppetite_avg_fields {
  level: Float
}

# order by avg() on columns of table "TechnicalAppetite"
input TechnicalAppetite_avg_order_by {
  level: order_by
}

# Boolean expression to filter rows from the table "TechnicalAppetite". All fields are combined with a logical 'AND'.
input TechnicalAppetite_bool_exp {
  Skill: Skill_bool_exp
  User: User_bool_exp
  _and: [TechnicalAppetite_bool_exp]
  _not: TechnicalAppetite_bool_exp
  _or: [TechnicalAppetite_bool_exp]
  created_at: date_comparison_exp
  level: Int_comparison_exp
  skillId: uuid_comparison_exp
  userEmail: String_comparison_exp
}

# unique or primary key constraints on table "TechnicalAppetite"
enum TechnicalAppetite_constraint {
  # unique or primary key constraint
  TechnicalAppetite_pkey
}

# input type for incrementing integer column in table "TechnicalAppetite"
input TechnicalAppetite_inc_input {
  level: Int
}

# input type for inserting data into table "TechnicalAppetite"
input TechnicalAppetite_insert_input {
  Skill: Skill_obj_rel_insert_input
  User: User_obj_rel_insert_input
  created_at: date
  level: Int
  skillId: uuid
  userEmail: String
}

# aggregate max on columns
type TechnicalAppetite_max_fields {
  created_at: date
  level: Int
  skillId: uuid
  userEmail: String
}

# order by max() on columns of table "TechnicalAppetite"
input TechnicalAppetite_max_order_by {
  created_at: order_by
  level: order_by
  skillId: order_by
  userEmail: order_by
}

# aggregate min on columns
type TechnicalAppetite_min_fields {
  created_at: date
  level: Int
  skillId: uuid
  userEmail: String
}

# order by min() on columns of table "TechnicalAppetite"
input TechnicalAppetite_min_order_by {
  created_at: order_by
  level: order_by
  skillId: order_by
  userEmail: order_by
}

# response of any mutation on the table "TechnicalAppetite"
type TechnicalAppetite_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [TechnicalAppetite!]!
}

# input type for inserting object relation for remote table "TechnicalAppetite"
input TechnicalAppetite_obj_rel_insert_input {
  data: TechnicalAppetite_insert_input!
  on_conflict: TechnicalAppetite_on_conflict
}

# on conflict condition type for table "TechnicalAppetite"
input TechnicalAppetite_on_conflict {
  constraint: TechnicalAppetite_constraint!
  update_columns: [TechnicalAppetite_update_column!]!
  where: TechnicalAppetite_bool_exp
}

# ordering options when selecting data from "TechnicalAppetite"
input TechnicalAppetite_order_by {
  Skill: Skill_order_by
  User: User_order_by
  created_at: order_by
  level: order_by
  skillId: order_by
  userEmail: order_by
}

# primary key columns input for table: "TechnicalAppetite"
input TechnicalAppetite_pk_columns_input {
  created_at: date!
  skillId: uuid!
  userEmail: String!
}

# select columns of table "TechnicalAppetite"
enum TechnicalAppetite_select_column {
  # column name
  created_at

  # column name
  level

  # column name
  skillId

  # column name
  userEmail
}

# input type for updating data in table "TechnicalAppetite"
input TechnicalAppetite_set_input {
  created_at: date
  level: Int
  skillId: uuid
  userEmail: String
}

# aggregate stddev on columns
type TechnicalAppetite_stddev_fields {
  level: Float
}

# order by stddev() on columns of table "TechnicalAppetite"
input TechnicalAppetite_stddev_order_by {
  level: order_by
}

# aggregate stddev_pop on columns
type TechnicalAppetite_stddev_pop_fields {
  level: Float
}

# order by stddev_pop() on columns of table "TechnicalAppetite"
input TechnicalAppetite_stddev_pop_order_by {
  level: order_by
}

# aggregate stddev_samp on columns
type TechnicalAppetite_stddev_samp_fields {
  level: Float
}

# order by stddev_samp() on columns of table "TechnicalAppetite"
input TechnicalAppetite_stddev_samp_order_by {
  level: order_by
}

# aggregate sum on columns
type TechnicalAppetite_sum_fields {
  level: Int
}

# order by sum() on columns of table "TechnicalAppetite"
input TechnicalAppetite_sum_order_by {
  level: order_by
}

# update columns of table "TechnicalAppetite"
enum TechnicalAppetite_update_column {
  # column name
  created_at

  # column name
  level

  # column name
  skillId

  # column name
  userEmail
}

# aggregate var_pop on columns
type TechnicalAppetite_var_pop_fields {
  level: Float
}

# order by var_pop() on columns of table "TechnicalAppetite"
input TechnicalAppetite_var_pop_order_by {
  level: order_by
}

# aggregate var_samp on columns
type TechnicalAppetite_var_samp_fields {
  level: Float
}

# order by var_samp() on columns of table "TechnicalAppetite"
input TechnicalAppetite_var_samp_order_by {
  level: order_by
}

# aggregate variance on columns
type TechnicalAppetite_variance_fields {
  level: Float
}

# order by variance() on columns of table "TechnicalAppetite"
input TechnicalAppetite_variance_order_by {
  level: order_by
}

# A Relay Connection object on "TechnicalAppetite"
type TechnicalAppetiteConnection {
  edges: [TechnicalAppetiteEdge!]!
  pageInfo: PageInfo!
}

type TechnicalAppetiteEdge {
  cursor: String!
  node: TechnicalAppetite!
}

# columns and relationships of "Topic"
type Topic implements Node {
  # An array relationship
  Skills(
    # distinct select on columns
    distinct_on: [Skill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [Skill_order_by!]

    # filter the rows returned
    where: Skill_bool_exp
  ): [Skill!]!

  # An aggregated array relationship
  Skills_aggregate(
    # distinct select on columns
    distinct_on: [Skill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [Skill_order_by!]

    # filter the rows returned
    where: Skill_bool_exp
  ): Skill_aggregate!

  # An array relationship connection
  Skills_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [Skill_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [Skill_order_by!]

    # filter the rows returned
    where: Skill_bool_exp
  ): SkillConnection!

  # An array relationship
  UserTopics(
    # distinct select on columns
    distinct_on: [UserTopic_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserTopic_order_by!]

    # filter the rows returned
    where: UserTopic_bool_exp
  ): [UserTopic!]!

  # An aggregated array relationship
  UserTopics_aggregate(
    # distinct select on columns
    distinct_on: [UserTopic_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserTopic_order_by!]

    # filter the rows returned
    where: UserTopic_bool_exp
  ): UserTopic_aggregate!

  # An array relationship connection
  UserTopics_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserTopic_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserTopic_order_by!]

    # filter the rows returned
    where: UserTopic_bool_exp
  ): UserTopicConnection!
  id: ID!
  name: String!
}

# aggregated selection of "Topic"
type Topic_aggregate {
  aggregate: Topic_aggregate_fields
  nodes: [Topic!]!
}

# aggregate fields of "Topic"
type Topic_aggregate_fields {
  count(columns: [Topic_select_column!], distinct: Boolean): Int
  max: Topic_max_fields
  min: Topic_min_fields
}

# order by aggregate values of table "Topic"
input Topic_aggregate_order_by {
  count: order_by
  max: Topic_max_order_by
  min: Topic_min_order_by
}

# input type for inserting array relation for remote table "Topic"
input Topic_arr_rel_insert_input {
  data: [Topic_insert_input!]!
  on_conflict: Topic_on_conflict
}

# Boolean expression to filter rows from the table "Topic". All fields are combined with a logical 'AND'.
input Topic_bool_exp {
  Skills: Skill_bool_exp
  UserTopics: UserTopic_bool_exp
  _and: [Topic_bool_exp]
  _not: Topic_bool_exp
  _or: [Topic_bool_exp]
  id: uuid_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "Topic"
enum Topic_constraint {
  # unique or primary key constraint
  Topic_name_key

  # unique or primary key constraint
  Topic_pkey
}

# input type for inserting data into table "Topic"
input Topic_insert_input {
  Skills: Skill_arr_rel_insert_input
  UserTopics: UserTopic_arr_rel_insert_input
  id: uuid
  name: String
}

# aggregate max on columns
type Topic_max_fields {
  id: uuid
  name: String
}

# order by max() on columns of table "Topic"
input Topic_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type Topic_min_fields {
  id: uuid
  name: String
}

# order by min() on columns of table "Topic"
input Topic_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "Topic"
type Topic_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [Topic!]!
}

# input type for inserting object relation for remote table "Topic"
input Topic_obj_rel_insert_input {
  data: Topic_insert_input!
  on_conflict: Topic_on_conflict
}

# on conflict condition type for table "Topic"
input Topic_on_conflict {
  constraint: Topic_constraint!
  update_columns: [Topic_update_column!]!
  where: Topic_bool_exp
}

# ordering options when selecting data from "Topic"
input Topic_order_by {
  Skills_aggregate: Skill_aggregate_order_by
  UserTopics_aggregate: UserTopic_aggregate_order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "Topic"
input Topic_pk_columns_input {
  id: uuid!
}

# select columns of table "Topic"
enum Topic_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "Topic"
input Topic_set_input {
  id: uuid
  name: String
}

# update columns of table "Topic"
enum Topic_update_column {
  # column name
  id

  # column name
  name
}

# A Relay Connection object on "Topic"
type TopicConnection {
  edges: [TopicEdge!]!
  pageInfo: PageInfo!
}

type TopicEdge {
  cursor: String!
  node: Topic!
}

# columns and relationships of "User"
type User implements Node {
  # An array relationship
  TechnicalAppetites(
    # distinct select on columns
    distinct_on: [TechnicalAppetite_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [TechnicalAppetite_order_by!]

    # filter the rows returned
    where: TechnicalAppetite_bool_exp
  ): [TechnicalAppetite!]!

  # An aggregated array relationship
  TechnicalAppetites_aggregate(
    # distinct select on columns
    distinct_on: [TechnicalAppetite_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [TechnicalAppetite_order_by!]

    # filter the rows returned
    where: TechnicalAppetite_bool_exp
  ): TechnicalAppetite_aggregate!

  # An array relationship connection
  TechnicalAppetites_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [TechnicalAppetite_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [TechnicalAppetite_order_by!]

    # filter the rows returned
    where: TechnicalAppetite_bool_exp
  ): TechnicalAppetiteConnection!

  # An array relationship
  UserAgencies(
    # distinct select on columns
    distinct_on: [UserAgency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserAgency_order_by!]

    # filter the rows returned
    where: UserAgency_bool_exp
  ): [UserAgency!]!

  # An aggregated array relationship
  UserAgencies_aggregate(
    # distinct select on columns
    distinct_on: [UserAgency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserAgency_order_by!]

    # filter the rows returned
    where: UserAgency_bool_exp
  ): UserAgency_aggregate!

  # An array relationship connection
  UserAgencies_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserAgency_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserAgency_order_by!]

    # filter the rows returned
    where: UserAgency_bool_exp
  ): UserAgencyConnection!

  # An array relationship
  UserSkills(
    # distinct select on columns
    distinct_on: [UserSkill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserSkill_order_by!]

    # filter the rows returned
    where: UserSkill_bool_exp
  ): [UserSkill!]!

  # An aggregated array relationship
  UserSkills_aggregate(
    # distinct select on columns
    distinct_on: [UserSkill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserSkill_order_by!]

    # filter the rows returned
    where: UserSkill_bool_exp
  ): UserSkill_aggregate!

  # An array relationship connection
  UserSkills_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserSkill_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserSkill_order_by!]

    # filter the rows returned
    where: UserSkill_bool_exp
  ): UserSkillConnection!

  # An array relationship
  UserTopics(
    # distinct select on columns
    distinct_on: [UserTopic_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserTopic_order_by!]

    # filter the rows returned
    where: UserTopic_bool_exp
  ): [UserTopic!]!

  # An aggregated array relationship
  UserTopics_aggregate(
    # distinct select on columns
    distinct_on: [UserTopic_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [UserTopic_order_by!]

    # filter the rows returned
    where: UserTopic_bool_exp
  ): UserTopic_aggregate!

  # An array relationship connection
  UserTopics_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [UserTopic_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [UserTopic_order_by!]

    # filter the rows returned
    where: UserTopic_bool_exp
  ): UserTopicConnection!
  email: String!
  id: ID!
}

# aggregated selection of "User"
type User_aggregate {
  aggregate: User_aggregate_fields
  nodes: [User!]!
}

# aggregate fields of "User"
type User_aggregate_fields {
  count(columns: [User_select_column!], distinct: Boolean): Int
  max: User_max_fields
  min: User_min_fields
}

# order by aggregate values of table "User"
input User_aggregate_order_by {
  count: order_by
  max: User_max_order_by
  min: User_min_order_by
}

# input type for inserting array relation for remote table "User"
input User_arr_rel_insert_input {
  data: [User_insert_input!]!
  on_conflict: User_on_conflict
}

# Boolean expression to filter rows from the table "User". All fields are combined with a logical 'AND'.
input User_bool_exp {
  TechnicalAppetites: TechnicalAppetite_bool_exp
  UserAgencies: UserAgency_bool_exp
  UserSkills: UserSkill_bool_exp
  UserTopics: UserTopic_bool_exp
  _and: [User_bool_exp]
  _not: User_bool_exp
  _or: [User_bool_exp]
  email: String_comparison_exp
}

# unique or primary key constraints on table "User"
enum User_constraint {
  # unique or primary key constraint
  User_pkey
}

# input type for inserting data into table "User"
input User_insert_input {
  TechnicalAppetites: TechnicalAppetite_arr_rel_insert_input
  UserAgencies: UserAgency_arr_rel_insert_input
  UserSkills: UserSkill_arr_rel_insert_input
  UserTopics: UserTopic_arr_rel_insert_input
  email: String
}

# aggregate max on columns
type User_max_fields {
  email: String
}

# order by max() on columns of table "User"
input User_max_order_by {
  email: order_by
}

# aggregate min on columns
type User_min_fields {
  email: String
}

# order by min() on columns of table "User"
input User_min_order_by {
  email: order_by
}

# response of any mutation on the table "User"
type User_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [User!]!
}

# input type for inserting object relation for remote table "User"
input User_obj_rel_insert_input {
  data: User_insert_input!
  on_conflict: User_on_conflict
}

# on conflict condition type for table "User"
input User_on_conflict {
  constraint: User_constraint!
  update_columns: [User_update_column!]!
  where: User_bool_exp
}

# ordering options when selecting data from "User"
input User_order_by {
  TechnicalAppetites_aggregate: TechnicalAppetite_aggregate_order_by
  UserAgencies_aggregate: UserAgency_aggregate_order_by
  UserSkills_aggregate: UserSkill_aggregate_order_by
  UserTopics_aggregate: UserTopic_aggregate_order_by
  email: order_by
}

# primary key columns input for table: "User"
input User_pk_columns_input {
  email: String!
}

# select columns of table "User"
enum User_select_column {
  # column name
  email
}

# input type for updating data in table "User"
input User_set_input {
  email: String
}

# update columns of table "User"
enum User_update_column {
  # column name
  email
}

# columns and relationships of "UserAgency"
type UserAgency implements Node {
  # An object relationship
  Agency: Agency!

  # An object relationship
  User: User!
  agency: String!
  id: ID!
  updatedAt: date!
  userEmail: String!
}

# aggregated selection of "UserAgency"
type UserAgency_aggregate {
  aggregate: UserAgency_aggregate_fields
  nodes: [UserAgency!]!
}

# aggregate fields of "UserAgency"
type UserAgency_aggregate_fields {
  count(columns: [UserAgency_select_column!], distinct: Boolean): Int
  max: UserAgency_max_fields
  min: UserAgency_min_fields
}

# order by aggregate values of table "UserAgency"
input UserAgency_aggregate_order_by {
  count: order_by
  max: UserAgency_max_order_by
  min: UserAgency_min_order_by
}

# input type for inserting array relation for remote table "UserAgency"
input UserAgency_arr_rel_insert_input {
  data: [UserAgency_insert_input!]!
  on_conflict: UserAgency_on_conflict
}

# Boolean expression to filter rows from the table "UserAgency". All fields are combined with a logical 'AND'.
input UserAgency_bool_exp {
  Agency: Agency_bool_exp
  User: User_bool_exp
  _and: [UserAgency_bool_exp]
  _not: UserAgency_bool_exp
  _or: [UserAgency_bool_exp]
  agency: String_comparison_exp
  id: uuid_comparison_exp
  updatedAt: date_comparison_exp
  userEmail: String_comparison_exp
}

# unique or primary key constraints on table "UserAgency"
enum UserAgency_constraint {
  # unique or primary key constraint
  UserAgency_pkey
}

# input type for inserting data into table "UserAgency"
input UserAgency_insert_input {
  Agency: Agency_obj_rel_insert_input
  User: User_obj_rel_insert_input
  agency: String
  id: uuid
  updatedAt: date
  userEmail: String
}

# aggregate max on columns
type UserAgency_max_fields {
  agency: String
  id: uuid
  updatedAt: date
  userEmail: String
}

# order by max() on columns of table "UserAgency"
input UserAgency_max_order_by {
  agency: order_by
  id: order_by
  updatedAt: order_by
  userEmail: order_by
}

# aggregate min on columns
type UserAgency_min_fields {
  agency: String
  id: uuid
  updatedAt: date
  userEmail: String
}

# order by min() on columns of table "UserAgency"
input UserAgency_min_order_by {
  agency: order_by
  id: order_by
  updatedAt: order_by
  userEmail: order_by
}

# response of any mutation on the table "UserAgency"
type UserAgency_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [UserAgency!]!
}

# input type for inserting object relation for remote table "UserAgency"
input UserAgency_obj_rel_insert_input {
  data: UserAgency_insert_input!
  on_conflict: UserAgency_on_conflict
}

# on conflict condition type for table "UserAgency"
input UserAgency_on_conflict {
  constraint: UserAgency_constraint!
  update_columns: [UserAgency_update_column!]!
  where: UserAgency_bool_exp
}

# ordering options when selecting data from "UserAgency"
input UserAgency_order_by {
  Agency: Agency_order_by
  User: User_order_by
  agency: order_by
  id: order_by
  updatedAt: order_by
  userEmail: order_by
}

# primary key columns input for table: "UserAgency"
input UserAgency_pk_columns_input {
  id: uuid!
}

# select columns of table "UserAgency"
enum UserAgency_select_column {
  # column name
  agency

  # column name
  id

  # column name
  updatedAt

  # column name
  userEmail
}

# input type for updating data in table "UserAgency"
input UserAgency_set_input {
  agency: String
  id: uuid
  updatedAt: date
  userEmail: String
}

# update columns of table "UserAgency"
enum UserAgency_update_column {
  # column name
  agency

  # column name
  id

  # column name
  updatedAt

  # column name
  userEmail
}

# A Relay Connection object on "UserAgency"
type UserAgencyConnection {
  edges: [UserAgencyEdge!]!
  pageInfo: PageInfo!
}

type UserAgencyEdge {
  cursor: String!
  node: UserAgency!
}

# A Relay Connection object on "User"
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String!
  node: User!
}

# columns and relationships of "UserSkill"
type UserSkill implements Node {
  # An object relationship
  Skill: Skill!

  # An object relationship
  User: User!
  created_at: date!
  id: ID!
  level: Int!
  skillId: uuid!
  userEmail: String!
}

# aggregated selection of "UserSkill"
type UserSkill_aggregate {
  aggregate: UserSkill_aggregate_fields
  nodes: [UserSkill!]!
}

# aggregate fields of "UserSkill"
type UserSkill_aggregate_fields {
  avg: UserSkill_avg_fields
  count(columns: [UserSkill_select_column!], distinct: Boolean): Int
  max: UserSkill_max_fields
  min: UserSkill_min_fields
  stddev: UserSkill_stddev_fields
  stddev_pop: UserSkill_stddev_pop_fields
  stddev_samp: UserSkill_stddev_samp_fields
  sum: UserSkill_sum_fields
  var_pop: UserSkill_var_pop_fields
  var_samp: UserSkill_var_samp_fields
  variance: UserSkill_variance_fields
}

# order by aggregate values of table "UserSkill"
input UserSkill_aggregate_order_by {
  avg: UserSkill_avg_order_by
  count: order_by
  max: UserSkill_max_order_by
  min: UserSkill_min_order_by
  stddev: UserSkill_stddev_order_by
  stddev_pop: UserSkill_stddev_pop_order_by
  stddev_samp: UserSkill_stddev_samp_order_by
  sum: UserSkill_sum_order_by
  var_pop: UserSkill_var_pop_order_by
  var_samp: UserSkill_var_samp_order_by
  variance: UserSkill_variance_order_by
}

# input type for inserting array relation for remote table "UserSkill"
input UserSkill_arr_rel_insert_input {
  data: [UserSkill_insert_input!]!
  on_conflict: UserSkill_on_conflict
}

# aggregate avg on columns
type UserSkill_avg_fields {
  level: Float
}

# order by avg() on columns of table "UserSkill"
input UserSkill_avg_order_by {
  level: order_by
}

# Boolean expression to filter rows from the table "UserSkill". All fields are combined with a logical 'AND'.
input UserSkill_bool_exp {
  Skill: Skill_bool_exp
  User: User_bool_exp
  _and: [UserSkill_bool_exp]
  _not: UserSkill_bool_exp
  _or: [UserSkill_bool_exp]
  created_at: date_comparison_exp
  level: Int_comparison_exp
  skillId: uuid_comparison_exp
  userEmail: String_comparison_exp
}

# unique or primary key constraints on table "UserSkill"
enum UserSkill_constraint {
  # unique or primary key constraint
  UserSkill_pkey
}

# input type for incrementing integer column in table "UserSkill"
input UserSkill_inc_input {
  level: Int
}

# input type for inserting data into table "UserSkill"
input UserSkill_insert_input {
  Skill: Skill_obj_rel_insert_input
  User: User_obj_rel_insert_input
  created_at: date
  level: Int
  skillId: uuid
  userEmail: String
}

# aggregate max on columns
type UserSkill_max_fields {
  created_at: date
  level: Int
  skillId: uuid
  userEmail: String
}

# order by max() on columns of table "UserSkill"
input UserSkill_max_order_by {
  created_at: order_by
  level: order_by
  skillId: order_by
  userEmail: order_by
}

# aggregate min on columns
type UserSkill_min_fields {
  created_at: date
  level: Int
  skillId: uuid
  userEmail: String
}

# order by min() on columns of table "UserSkill"
input UserSkill_min_order_by {
  created_at: order_by
  level: order_by
  skillId: order_by
  userEmail: order_by
}

# response of any mutation on the table "UserSkill"
type UserSkill_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [UserSkill!]!
}

# input type for inserting object relation for remote table "UserSkill"
input UserSkill_obj_rel_insert_input {
  data: UserSkill_insert_input!
  on_conflict: UserSkill_on_conflict
}

# on conflict condition type for table "UserSkill"
input UserSkill_on_conflict {
  constraint: UserSkill_constraint!
  update_columns: [UserSkill_update_column!]!
  where: UserSkill_bool_exp
}

# ordering options when selecting data from "UserSkill"
input UserSkill_order_by {
  Skill: Skill_order_by
  User: User_order_by
  created_at: order_by
  level: order_by
  skillId: order_by
  userEmail: order_by
}

# primary key columns input for table: "UserSkill"
input UserSkill_pk_columns_input {
  created_at: date!
  skillId: uuid!
  userEmail: String!
}

# select columns of table "UserSkill"
enum UserSkill_select_column {
  # column name
  created_at

  # column name
  level

  # column name
  skillId

  # column name
  userEmail
}

# input type for updating data in table "UserSkill"
input UserSkill_set_input {
  created_at: date
  level: Int
  skillId: uuid
  userEmail: String
}

# aggregate stddev on columns
type UserSkill_stddev_fields {
  level: Float
}

# order by stddev() on columns of table "UserSkill"
input UserSkill_stddev_order_by {
  level: order_by
}

# aggregate stddev_pop on columns
type UserSkill_stddev_pop_fields {
  level: Float
}

# order by stddev_pop() on columns of table "UserSkill"
input UserSkill_stddev_pop_order_by {
  level: order_by
}

# aggregate stddev_samp on columns
type UserSkill_stddev_samp_fields {
  level: Float
}

# order by stddev_samp() on columns of table "UserSkill"
input UserSkill_stddev_samp_order_by {
  level: order_by
}

# aggregate sum on columns
type UserSkill_sum_fields {
  level: Int
}

# order by sum() on columns of table "UserSkill"
input UserSkill_sum_order_by {
  level: order_by
}

# update columns of table "UserSkill"
enum UserSkill_update_column {
  # column name
  created_at

  # column name
  level

  # column name
  skillId

  # column name
  userEmail
}

# aggregate var_pop on columns
type UserSkill_var_pop_fields {
  level: Float
}

# order by var_pop() on columns of table "UserSkill"
input UserSkill_var_pop_order_by {
  level: order_by
}

# aggregate var_samp on columns
type UserSkill_var_samp_fields {
  level: Float
}

# order by var_samp() on columns of table "UserSkill"
input UserSkill_var_samp_order_by {
  level: order_by
}

# aggregate variance on columns
type UserSkill_variance_fields {
  level: Float
}

# order by variance() on columns of table "UserSkill"
input UserSkill_variance_order_by {
  level: order_by
}

# A Relay Connection object on "UserSkill"
type UserSkillConnection {
  edges: [UserSkillEdge!]!
  pageInfo: PageInfo!
}

type UserSkillEdge {
  cursor: String!
  node: UserSkill!
}

# columns and relationships of "UserTopic"
type UserTopic implements Node {
  # An object relationship
  Topic: Topic!

  # An object relationship
  User: User!
  created_at: date!
  id: ID!
  topicId: uuid!
  userEmail: String!
}

# aggregated selection of "UserTopic"
type UserTopic_aggregate {
  aggregate: UserTopic_aggregate_fields
  nodes: [UserTopic!]!
}

# aggregate fields of "UserTopic"
type UserTopic_aggregate_fields {
  count(columns: [UserTopic_select_column!], distinct: Boolean): Int
  max: UserTopic_max_fields
  min: UserTopic_min_fields
}

# order by aggregate values of table "UserTopic"
input UserTopic_aggregate_order_by {
  count: order_by
  max: UserTopic_max_order_by
  min: UserTopic_min_order_by
}

# input type for inserting array relation for remote table "UserTopic"
input UserTopic_arr_rel_insert_input {
  data: [UserTopic_insert_input!]!
  on_conflict: UserTopic_on_conflict
}

# Boolean expression to filter rows from the table "UserTopic". All fields are combined with a logical 'AND'.
input UserTopic_bool_exp {
  Topic: Topic_bool_exp
  User: User_bool_exp
  _and: [UserTopic_bool_exp]
  _not: UserTopic_bool_exp
  _or: [UserTopic_bool_exp]
  created_at: date_comparison_exp
  topicId: uuid_comparison_exp
  userEmail: String_comparison_exp
}

# unique or primary key constraints on table "UserTopic"
enum UserTopic_constraint {
  # unique or primary key constraint
  UserTopic_pkey
}

# input type for inserting data into table "UserTopic"
input UserTopic_insert_input {
  Topic: Topic_obj_rel_insert_input
  User: User_obj_rel_insert_input
  created_at: date
  topicId: uuid
  userEmail: String
}

# aggregate max on columns
type UserTopic_max_fields {
  created_at: date
  topicId: uuid
  userEmail: String
}

# order by max() on columns of table "UserTopic"
input UserTopic_max_order_by {
  created_at: order_by
  topicId: order_by
  userEmail: order_by
}

# aggregate min on columns
type UserTopic_min_fields {
  created_at: date
  topicId: uuid
  userEmail: String
}

# order by min() on columns of table "UserTopic"
input UserTopic_min_order_by {
  created_at: order_by
  topicId: order_by
  userEmail: order_by
}

# response of any mutation on the table "UserTopic"
type UserTopic_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [UserTopic!]!
}

# input type for inserting object relation for remote table "UserTopic"
input UserTopic_obj_rel_insert_input {
  data: UserTopic_insert_input!
  on_conflict: UserTopic_on_conflict
}

# on conflict condition type for table "UserTopic"
input UserTopic_on_conflict {
  constraint: UserTopic_constraint!
  update_columns: [UserTopic_update_column!]!
  where: UserTopic_bool_exp
}

# ordering options when selecting data from "UserTopic"
input UserTopic_order_by {
  Topic: Topic_order_by
  User: User_order_by
  created_at: order_by
  topicId: order_by
  userEmail: order_by
}

# primary key columns input for table: "UserTopic"
input UserTopic_pk_columns_input {
  created_at: date!
  topicId: uuid!
  userEmail: String!
}

# select columns of table "UserTopic"
enum UserTopic_select_column {
  # column name
  created_at

  # column name
  topicId

  # column name
  userEmail
}

# input type for updating data in table "UserTopic"
input UserTopic_set_input {
  created_at: date
  topicId: uuid
  userEmail: String
}

# update columns of table "UserTopic"
enum UserTopic_update_column {
  # column name
  created_at

  # column name
  topicId

  # column name
  userEmail
}

# A Relay Connection object on "UserTopic"
type UserTopicConnection {
  edges: [UserTopicEdge!]!
  pageInfo: PageInfo!
}

type UserTopicEdge {
  cursor: String!
  node: UserTopic!
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

